namespace OwlTree.Tests;

public class HuffmanTests
{
    [Fact]
    public void HuffmanTest()
    {
        var sendPacket = new Packet(100);
        sendPacket.header.owlTreeVer = 1;
        sendPacket.header.appVer = 14;
        sendPacket.header.timestamp = 0x1122334455;
        sendPacket.header.sender = 1;
        sendPacket.header.hash = 0x44334433;
        sendPacket.header.compressionEnabled = true;

        for (int i = 1; i < 5; i++)
        {
            var span = sendPacket.GetSpan(20);
            for (int j = 0; j < span.Length; j++)
                span[j] = (byte)i;
        }

        var bytes1 = sendPacket.GetPacket().ToArray();

        Huffman.Encode(sendPacket);

        var bytes3 = sendPacket.GetPacket().ToArray();

        Huffman.Decode(sendPacket);
        
        var bytes2 = sendPacket.GetPacket().ToArray();

        Assert.Fail("\n" + BitConverter.ToString(bytes1) + "\n\n" + BitConverter.ToString(bytes3) + "\n\n" + BitConverter.ToString(bytes2));
    }

    [Fact]
    public void HuffmanTest2()
    {
        var bytes = new byte[]{0x01,0x00,0x01,0x00,0xE6,0xCD,0xB2,0x28,0x94,0x01,0x00,0x00,0x94,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x38,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x78,0xCA,0x70,0x3F,0xA5,0x14,0xB3,0xC0,0x96,0x8A,0x65,
        0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x38,0x00,0x00,
        0x00,0x18,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x90,0xC2,0x85,0x40,0x0A,0xD7,0xBB,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x38,0x00,0x00,0x00,0x18,0x00,0x00,
        0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x78,0xCA,0x70,0x3F,0x6C,0xE8,0xB5,0xC0,0x96,0x8A,0x65,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x38,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x01,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x90,0xC2,0x85,0x40,0x0A,0xD7,0xBB,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x1C,0x00,0x00,0x00,0x14,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x04,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x03,0x00,0x00,0x00,0x78,0xCA,0x70,0x3F,0x59,0xDC,0xB8,0xC0,0x96,0x8A,0x65,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
        0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x38,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,
        0x00,0x90,0xC2,0x85,0x40,0x0A,0xD7,0xBB,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,
        0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x38,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x78,0xCA,0x70,
        0x3F,0x6B,0xF0,0xBB,0xC0,0x96,0x8A,0x65,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,
        0x3F,0x00,0x00,0x80,0x3F,0x38,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x90,0xC2,0x85,0x40,0x0A,0xD7,0xBB,
        0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,
        0x3F,0x38,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x78,0xCA,0x70,0x3F,0x1D,0xDC,0xBB,0xC0,0x96,0x8A,0x65,
        0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x38,0x00,0x00,
        0x00,0x18,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x90,0xC2,0x85,0x40,0x0A,0xD7,0xBB,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F,0x00,0x00,0x80,0x3F};

        var packet = new Packet(bytes.Length + 10);
        packet.FromBytes(bytes, 0);

        // var bytes5 = packet.GetMessages();
        // var histogram = Huffman.BuildHistogram(bytes, out var unique);
        // var tree = Huffman.BuildEncodingTree(histogram);
        // // Assert.Fail(tree.ToString());

        // var table = new Huffman.ByteEncoding[byte.MaxValue + 1];
        // Huffman.BuildEncodingTable(table, tree);

        // var tableStr = "Encodings:\n";
        // foreach (var e in table)
        // {
        //     if (e.bitLen > 0)
        //     {
        //         tableStr += $"    {e.value:X2} : {e}\n";
        //     }
        // }
        // Assert.Fail("\n" + tableStr);

        var bytes1 = packet.GetPacket().ToArray();

        Huffman.Encode(packet);

        var bytes3 = packet.GetPacket().ToArray();

        Huffman.Decode(packet);
        
        var bytes2 = packet.GetPacket().ToArray();

        Assert.Fail("\n" + BitConverter.ToString(bytes1) + "\n\n" + BitConverter.ToString(bytes3) + "\n\n" + BitConverter.ToString(bytes2));
    }

    [Fact]
    public void QuantizationTest()
    {
        var noQuant = new Packet(6000);
        var withQuant = new Packet(6000);

        var bytes1 = noQuant.GetSpan(4 * 600);
        var bytes2 = withQuant.GetSpan(600);
        var rand = new Random();
        var floats = new float[20];
        for (int i = 0; i < floats.Length; i++)
        {
            floats[i] = rand.NextSingle();
        }

        for (int i = 0; i < bytes2.Length; i++)
        {
            var next = floats[i % floats.Length];
            BitConverter.TryWriteBytes(bytes1.Slice(i * 4), next);
            bytes2[i] = (byte)(next * 255);
        }

        var originalPacket = noQuant.GetPacket().ToArray();
        var quantPacket = withQuant.GetPacket().ToArray();

        Huffman.Encode(noQuant);
        Huffman.Encode(withQuant);

        var compressed = noQuant.GetPacket().ToArray();
        var compWithQuant = withQuant.GetPacket().ToArray();

        Assert.Fail($"Results:\n   Original: {originalPacket.Length} vs {quantPacket.Length}\n   Compress: {compressed.Length} vs {compWithQuant.Length}\n   Factor: {(float)compressed.Length / originalPacket.Length} vs {(float)compWithQuant.Length / quantPacket.Length}\n");
    }
}